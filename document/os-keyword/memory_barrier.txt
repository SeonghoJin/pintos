비순차적 프로세서와 마찬가지로 컴파일러도 
비슷한 최적화를 수행합니다. 하지만 이 기능은 여러개의 
스레드에서 돌아 가는 경우, 코드의 실행 순서가 바뀌어 실행되는 동안
다른 스레드가 그 부분에 대한 메모리를 접근하여 잘못된 결과를 내놓을 수 있습니다. 
따라서 특정 부분에 대해서 실행순서를 강제한느 메모리 배리어를 놓아야합니다. 

다음과 같은 코드가 있다고 했을 때, 
static void NO_INLINE
busy_wait (int64_t loops) 
{
  while (loops-- > 0)
    barrier ();
}

loops변수는 부수효과도 없고 의미가 없기 때문에 컴파일러가 삭제할 수 있습니다. 
따라서 배리어 함수는 컴파일러가 강제적으로 루프바디가 중요한 영향을 갖고 있다고 해서 

그리고 배리어 함수는 강제적으로 메모리 읽기, 쓰기 순서를 강제합니다. 
timer_put_char = ’x’;
barrier ();
timer_do_put = true;