이 프로젝트의 읽기전에 다음과 같은 챕터들을 읽고 오길 바란다 
Chpater 1의 Introduction, page 1
부록 C(코딩 표준), page96
부록 E(디버깅 도구), page 102
부록 F(개발 도구), page 113
부록 B(4.4BSD 스케쥴러), page 91를 읽어야 할 것이다.
섹션 A.1(핀토스 로딩) Page 58 부터 A.5(메모리 할당) page 75 
특히 A.3(싱크로나이제이션), page66

-요구사항
    - device/timer.c에 있는 timer_sleep함수를 다시 정의해라.
    - 기존에는 busy_waiting을 사용하여 timer_sleep함수가 되어 있지만, 
    busy_waiting을 하지 않고 다시 만들어라. 
    - 우선순위 스케쥴링을 구현해라. 현재 실행중인 쓰레드 보다 더 높은 우선순위를 
    가진 쓰레드가 준비 리스트에 더해진다면, 현재의 쓰레드는 즉시 프로세스를 새로운 
    쓰레드에 넘겨줘야한다. 비슷하게, lock, condition, semaphore, or condition 
    variable 등을 기다리고 있을때, 우선순위가 가장 높은 쓰레드를 깨워야합니다.
    - 초기 쓰레드의 우선순위는 thread_create함수에 맡긴다.
    - 만약 우선순위를 정할 숫자가 마땅치 않다면 31로 정하라.
    - 우선순위에 관한 문제 3가지
        - H, M, L이 있다고 가정하자. (H가 가장 높은 우선순위, M 중간, L 낮음)
        - H가 L을 기다리는 경우, 그리고 M이 준비 리스트에 있을 경우 
        - H는 절대 CPU를 얻을 수 없습니다. 왜냐하면 낮은 우선순위 쓰레드는 CPU시간을
        얻을 수 없기 때문입니다. 이 문제를 수정하는 한 방법은 H가 L이 락을 가지고 
        있는 동안 그것의 우선순위를 기부하는 것입니다. 그러면, L이 잠금을 풀면 회수하는 
        것입니다. 
    - 우선순위 기부를 구현하십시요. 
    - 우선순위 기부를 해야될 상황을 모두 고려해야 할 것입니다.
    - 여러 우선 순위가 단일 스레드에 기부되는 여러기부를 처리해야합니다.  
    - 중첩 기부도 처리해야합니다(만약 H가 M을 기다리고 M이 L을 기다릴 경우)
    - 필요한 경우 8번 중첩된 기부까지만 하도록 제한할 수 있습니다.

timer_sleep함수 
- 쓰레드 호출의 실행을 중단시킵니다. x 타이머 틱까지 진행될때까지
- 시스템이 유휴상태가 아닌 다른 것이라면, 쓰레드는 정확히 x 타이머 이후로 
깨어날 필요가 없습니다. 준비 큐에 그냥 넣고, 적당한 시간이 지날때까지 기다려야합니다. 

timer_sleep()은 실시간으로 쓰레드를 작동시키는데 유용합니다. 1초에 한번씩 깜박거리는 등.

