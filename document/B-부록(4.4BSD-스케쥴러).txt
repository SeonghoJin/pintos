scheduler의 목표는 thread들의 스케쥴링 사용량을 균형시키는 것입니다.
많은 I/O를 수행하는 Threads는 입력 및 출력 장치를 계속 사용하기 위해서
빠른 응답 시간이 필요하지만 CPU 시간은 그렇지 않는다. 반면에 compute-bound
threads는 작업을 끝내기 위해서 많은 시간이 있어야합니다. 그러나 빠른 응답시간
을 요구하지는 않습니다. 잘 설계된 스케쥴러는 이러한 모든 요구사항을 동시에 가진 스레드를 
잘 수용할 수 있어야 합니다.

project 1을 위해서 이 부록에 묘사된 스케쥴러를 구현해야합니다. 이 스케쥴러는 multilevel feedback
queue scheduler와 비슷하다. 이러한 형태의 스케쥴러는 즉시 실행 가능한 몇몇의 queue들을 가지고 있다.
언제든 스케쥴러는 비어있지않은 높은 우선순위의 큐로부터 스레드를 선택할 수 있다. 
만약 높은 우선순위 큐가 multiple 쓰레드를 가지고 있다면 round robin order에 따라서 
실행한다. 

스케쥴러는 다양한 곳에서 특정 timer tick 뒤에 데이터를 업데이트 하게 한다. 
대부분의 경우 이러한 업데이트는 일반적인 커널 스레드가 실행가능할때 일어나야한다. 
따라서 커널 스레드가 증가된 timer_ticks() 값을 볼 가능성이 없습니다. 결국 오래된 스케쥴러의 데이터는
보지 못합니다. 

스레드 우선순위는 주어진 공식에 따른 스케쥴러에 의해서 결정됩니다. 그러나 각 스레드는 
다른 스레드에 얼마나 "nice" 한지 결정하는 nice변수를 가지고 있습니다. 
0의 나이스는 스레드 우선순위에 영향을 끼치지 않습니다. 20이 최대인 양수인 나이스는 
스레드의 우선순위를 감소시키고, 다른곳에 주기 위해서 CPU시간을 포기하게끔 합니다.
반면에 -20이 최소인 음수의 나이스는 다른 쓰레드로부터 CPU시간을 취하도록 합니다. 

초기의 스레드는 0의 나이스를 가지고 있습니다. 또 다른 스레드는 부모 스레드의 nice를
받습니다. 

B.2 우선순위 계산
스케쥴러는 64개의 우선순위를 가지고 있고, 따라서 0부터 63까지 숫자를 가진 64개의 큐를 가지고 있습니다.
낮은 숫자는 낮은 우선순위와 대응하고 우선순위 0은 가장 낮은 우선순위를 가지며, 
63은 가장 높은 우선순위를 가집니다. 스레드 우선순위는 초기에 스레드가 생성될 때 계산됩니다.
모든 스레드에 대해서 한번씩 4번째 클럭마다 다시 계산됩니다. 이 두 경우 모두 공식에 의해서 
결정됩니다. 

priority = PRI_MAX - (recent_cpu / 4) - (nice * 2),

recent_cpu는 스레드가 최근에 사용 했던 cpu시간의 추정치입니다.
nice는 쓰레드의 nice변수 값입니다. 결과 값은 가장 가까운 정수로 내림되어야 합니다.
계산된 우선순위는 PRI_MIN 과 PRI_MAX사이에 있도록 잘 조절합니다.

B.3 recent_cpu 계산

현재로부터 n초내의 CPU시간을 추적하기 위해서 n개의 원소를 가진 배열을 사용하는 방법이 있다.
그러나 이러한 접근은 O(n)시간복잡도가걸린다. 대신에, 지수가중이동평균을 사용할 수 있다.

맨 첫번째로 생성된 쓰레드의 recent_cpu는 0이다. 다른 쓰레드는 부모의 값이다. 
timer intterupt가 일어날때마다, recent_cpu는 1씩 증가된다. 현재 실행된 thread만 유휴쓰레드가
실행중이 아니라면 
또한, recent_cpu는 초당 한 번 다시 계산된다. 다음과 같은 공식에 의해서

recent_cpu = (2*load_avg)/(2*load_avg + 1) * recent_cpu + nice

load_avg는 쓰레드가 즉시 실행하기 위한 이동평균이다. 만약 load_avg가 1이라면 
평균적으로 단일 스레드가 CPU와 경쟁하고 있음을 나타낸다.
여러가지 테스트를 통해 만들어진 가정은 recent_cpu의 재계산이 정확하게 되어야 한다고 요구한다. 
system tick 계산기가 1초의 배수에 달할때, 즉 timer_ticks() % TIMER_FREQ == 0일때

recent_cpu의 값은 음수의 nice값을 가진 쓰레드일때는 음수가 될 수 있습니다. 

먼저 recent_cpu계수를 계산하고 곱하라, 몇몇의 학생들은 recent_cpu에 곧바로 load_avg를
곱할 경우 overflow가 일어난다고 보고했다. 

B.4 load_avg 
마지막으로, load_avg는 지난 1분동안 실행될 준비가 된 평균 스레드 수를 추정합니다. 
recent_cpu와 달리 load_avg는 시스템적으로 넓게 사용됩니다. 특정쓰레드와 달리 
시스템이 켜질때, load_avg는 0으로 초기화 됩니다. 그 후 일초마다 다음 공식에 따라서 업데이트가
됩니다. 

load_avg = (59/60) * load_avg + (1/60)*ready_threads 
ready_threads는 업데이트 할때, 실행되거나 곧 실행할 쓰레드의 수이다.

B.5 요약
모든 스레드는 -20 부터 20까지의 nice숫자를 갖는다. 각 스레드는 우선순위를 가지며, 
이는 0부터 63 사이이고, 다음 4번째 틱마다 재계산 된다. 
    priority = PRI_MAX - (recent_cpu / 4) - (nice * 2)

recent_cpu는 CPU시간 양을 측정합니다. timer tick마다 실행중인 쓰레드의 recent_cpu를 
증가시킵니다. 1초에 한번씩 모든 쓰레드의 recent_cpu를 업데이트 합니다. 
recent_cpu = (2 * load_avg)/(2*load_avg + 1) * recent_cpu + nice

load_avg는 지난 1분동안 실행된 스레드의 평균 수를 측정합니다. 시작할때는 초기에 0으로
초기화되고 1초에 한번 재계산됩니다. 
load_avg = (59/60)*load_avg + (1/60)*ready_threads

ready_threads는 업데이트 될 때 실행중이거나 실행준비중인 스레드의 숫자입니다.(휴유 중인 스레드를 제외하고)
